<!--

  Built by Eric Mill:
    eric@konklone.com
    konklone.com
    twitter.com/konklone

  With majestic assistance from Micah Rich (@micahbrich) and Brandon Jones (@btj).

  Bug reports and stuff:
    github.com/isitchristmas/web/issues

-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Is it Christmas?</title>

  <link rel="alternate" title="Is It Christmas?" href="/rss.xml" type="application/rss+xml" />
  <link rel="warrant canary" title="Is It Still Christmas?" href="/canary.txt" type="text/plain" />

  <style type="text/css">
    html, body {height: 100%;}
    body {text-align: center;}

    a#answer {
      display: inline-block;
      margin-top: 200px;
      font-weight: bold;
      font-size: 120pt;
      font-family: Arial, sans-serif;
      text-decoration: none;
      color: black;
    }

    .flag {
      position: absolute;
      cursor: none;
    }

    .flag.me {pointer-events: none;}

    .flag img {
      border: 1px solid #d6d6d6;
      -webkit-border-radius: 2px;
           -o-border-radius: 2px;
              border-radius: 2px;

      -webkit-transition: opacity 1s;
         -moz-transition: opacity 1s;
           -o-transition: opacity 1s;
              transition: opacity 1s;
    }

    /* click effect, width and height set dynamically */
    .click {
      position: absolute;
      border: 1px solid #000;

      -webkit-border-radius: 3px;
              border-radius: 3px;

      -webkit-transition: 0.5s ease-out;
         -moz-transition: 0.5s ease-out;
           -o-transition: 0.5s ease-out;
              transition: 0.5s ease-out;
    }

    #legend {
      position: fixed;
      top: 0; right: 0;
      width: 200px;
      padding-right: 15px; padding-top: 5px;
      text-align: right;
      font-size: 10pt;

      -webkit-transition: 0.25s linear;
         -moz-transition: 0.25s linear;
           -o-transition: 0.25s linear;
              transition: 0.25s linear;
    }
  </style>

  <script type="text/javascript" src="/js/christmas.js"></script>

  <!--[if IE 9 ]>
    <script type="text/javascript">window._ie9 = true;</script>
  <![endif]-->
</head>

<body>
  <!--
    Initial 'title' and noscript values are server-side fallbacks,
    calculated with UTC, for clients who do not have JS enabled.
  -->
  <a id="answer"
    title="<%= answer %>">
    <noscript><%= answer %></noscript>
  </a>

  <div id="legend"></div>

  <!-- replace fallback data with locally calculated values -->
  <script type="text/javascript">
    var country = "<%= country %>";
    if (!(Christmas.countries[country] && Christmas.countries[country].width))
      country = "EO";

    var me = {
      country: country
    };

    var checkedAt; // store last check, to manage race conditions
    function updateChristmas(isIt) {
      me.christmas = isIt;

      var answer;
      if (isIt)
        answer = Christmas.yes(country);
      else
        answer = Christmas.no(country);

      var elem = document.getElementById('answer');
      elem.innerHTML = answer;
      elem.setAttribute("title", answer);

      checkedAt = Date.now();
    }

    updateChristmas(Christmas.isIt());
  </script>


  <% if (env == "production") { %>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-252618-5', 'isitchristmas.com');
      ga('set', 'anonymizeIp', true);
      ga('send', 'pageview');

    </script>
  <% } %>


  <!-- optional: interaction -->
  <script src="/js/browser.js"></script>
  <script src="/js/css.js"></script>
  <script src="/js/sockjs.min.js"></script>
  <script type="text/javascript">

    var socket;
    var others = {};

    var user = {
      log: {
        join: <%= config.log.join %>, // join/leave messages
        info: <%= config.log.info %>,   // default
        debug: <%= config.log.debug %>, // you know

        life: true,  // life and death events
        public: true // messages for the public
      },

      retry: {
        id: null, // the timeout id
        initial: 500, // milliseconds
        multiplier: 2, // multiply after every retry
        current: 500 // will change
      },

      // values will be overwritten on hello in production
      live: {
        mouse_rate: 20,
        heartbeat_interval: 3000,
        death_interval: 6000,
        chat: "true"
      }
    };

    me.flag = null;
    me.alreadyArrived = false;

    // sockjs server endpoint
    <% if (req.param("streaming")) { %>
      var url = "<%= req.param("streaming") %>/christmas";
    <% } else { %>
      <% var random = Math.floor(Math.random() * config.streaming.length); %>
      var url = "<%= config.streaming[random] %>/christmas";
    <% } %>

    // whether activity is visible to the user
    var visible = <%= (req.param("visible") || config.visible) ? "true" : "false" %>;

    // whether to force into readonly mode (see mice, but no sending of own action)
    var force_readonly = <%= req.param("readonly") || "false" %>;

    // force it to use a particular transport
    var transport = "<%= req.param("transport") || "" %>";

    // allowed transports
    var default_transports = [
      "websocket", // most everyone nowadays
      "xhr-streaming", // older versions of non-IE, and when networks block websockets
      "xdr-streaming" // IE9
    ];

    // tiny events/commands system
    var events = {};
    var commands = {};
    function on(event, func) {events[event] = func;}
    function command(cmd, func) {commands[cmd] = func;}
    function noop() {};

    // managing heartbeats
    var heartbeat, death;
    var suicide = false; // why would you do this

    var legend = document.getElementById("legend")
      , legendTimeout;

    var christmasTimer
      , christmasEndTimer;



/**** basic connection and event management ***/

    function connect(host) {
      socket = new SockJS(host, null, {
        protocols_whitelist: transport ? [transport] : default_transports
      });

      socket.onopen = function() {
        log.info("= Connected via " + socket.protocol);

        me.transport = socket.protocol;

        // XDR doesn't have good enough upstream speed for mouse motion
        me.readonly = force_readonly || (me.transport == "xdr-streaming");

        // reset retry timer, we're in
        user.retry.current = user.retry.initial;
      };

      socket.onclose = onDeath;

      socket.onmessage = function(message) {
        var data = JSON.parse(message.data);
        (events[data._event] || noop)(data);
      };
    }

    var rawSend = function(message) {socket.send(message)};
    var limiters = {
      chat: ratelimit(rawSend, 500),
      click: ratelimit(rawSend, 20),
      motion: ratelimitMouse(rawSend) // dynamic
    };

    function emit(event, data) {
      if (!me.id || !me.transport) {
        log.info("= Weird state! Trying to emit events when I have no ID. :|")
        return;
      }

      data = data || {};
      data._event = event;
      var message = JSON.stringify(data);
      (limiters[event] || rawSend)(message);
    }



/*** user join/leave management ***/

    on('hello', function(data) {
      log.info("= Assigned ID: " + data.user.id + " [on: " + data.server + "]");

      // used only directly by other clients when packets are blindly rebroadcast.
      // me.id will never be depended on by the server.
      me.id = data.user.id;

      // convenience only for console poking, can safely delete
      me.server = data.server;

      // TODO: make convenience only
      me.name = data.user.name;

      // server-overridden client options
      for (var key in data.live)
        user.live[key] = data.live[key];

      if (user.live.chat == "true")
        welcomeUser();

      me.browser = BrowserDetect.browser;
      me.os = BrowserDetect.OS;
      me.version = BrowserDetect.version;

      // all users announce their info to the server and start a heartbeat
      emit('arrive', myHeart());

      // update me to indicate I've sent 'arrive' once
      // server will know that future connects are reconnects
      me.alreadyArrived = true;

      setHeartbeat();
      setCursor(me.country);

      document.onmousemove = mouseMove;
      document.onmousedown = mouseClick;
    });

    // core user details
    var myHeart = function() {
      return {
        id: me.id, // used in rebroadcasting only
        alreadyArrived: me.alreadyArrived, // new or reconnect?
        country: me.country, // TODO: ditch, server-side
        transport: me.transport,
        browser: me.browser,
        version: me.version,
        os: me.os
      };
    };

    var onDeath = function() {
      log.life("= Disconnected! :(");

      clearTimeout(heartbeat);
      clearTimeout(death);

      for (var id in others)
        removeOther(id);

      document.onmousemove = null;
      document.onmousedown = null;

      me.id = null;
      me.transport = null;
      me.time = null;
      if (me.flag && me.flag.parentElement)
        me.flag.parentElement.removeChild(me.flag);

      setRetry();
    };

    var setRetry = function() {
      log.life("= Retrying in " + user.retry.current + "ms...");
      user.retry.id = setTimeout(function() {
        connect(url);
      }, user.retry.current);

      user.retry.current = user.retry.current * user.retry.multiplier;
    }

    var setHeartbeat = function() {
      clearTimeout(heartbeat);
      heartbeat = setTimeout(function() {
        log.debug("heartbeat: beating");
        emit("heartbeat", myHeart());
      }, parseInt(user.live.heartbeat_interval));

      death = setTimeout(function() {
        log.life("= Died from lack of heartbeat :(")
        socket.close();
      }, parseInt(user.live.death_interval));
    };

    on("heartbeat", function(data) {
      if (suicide) return; // let death take me

      clearTimeout(death); // death averted
      log.debug("heartbeat: returned, death averted");

      setHeartbeat();
    });

    on('arrive', function(other) {
      registerOther(other);

      // let a new arrival know you are already here
      emit("here", {to: other.id});
    });

    on('here', function(other) {
      registerOther(other);
    });

    on('leave', function(data) {
      removeOther(data.id);
    });


    var registerOther = function(other) {
      if (others[other.id]) return;

      others[other.id] = {country: other.country};

      log.join("[" + other.id + "] Joined from " + other.country + " (" + Christmas.countries[other.country].name + ")");
    };

    // the creation of an element per-user is only sparked by that user's mouse motion.
    // so read-only (non-WS) clients will connect and be known, but not cause
    // elements to be generated.
    var showOther = function(other) {
      // make up for shortened key name
      other.country = other.country || other.c;

      // in case this comes before the 'arrive' event does
      registerOther(other);

      others[other.id].flag = flagFor(other.country, "other");
      if (visible)
        document.body.appendChild(others[other.id].flag);
    };

    var removeOther = function(id) {
      if (!others[id]) return;
      var country = others[id].country;

      var elem = others[id].flag;
      if (elem && elem.parentElement)
        elem.parentElement.removeChild(elem);

      delete others[id];
      log.join("[" + id + "] Departed from " + country + " (" + Christmas.countries[country].name + ")");
    };



/**** FLAG MECHANICS ***/

    var setCursor = function(country) {
      me.flag = flagFor(country, "me");
      me.flag._new = true; // used to lazy-add element only if moved
      me.flag.style.zIndex = 9999; // on top of the world
    };

    var flagFor = function(country, klass) {
      var div = document.createElement('div');
      div.className = "flag " + klass;

      var flag = document.createElement('img');
      flag.src = "/countries/" + country + ".png";

      // create a legend in the top-right when you mouse over other people's flags
      div.onmouseover = function() {
        clearTimeout(legendTimeout);
        legend.innerHTML = Christmas.countries[country].names.join("<br/>");
        legend.style.opacity = 1;
        legendTimeout = setTimeout(function() {
          legend.style.opacity = 0;
        }, 30000)
      };

      div.appendChild(flag);

      // without this, div adds height padding, weird
      div.style.height = "20px";

      div.style.marginTop = "-10px"; // half of constant height 20
      div.style.marginLeft = "-" + (flagWidth(country) / 2) + "px";

      return div;
    };

    // there is sadly no international standard on flag aspect ratio
    var flagWidth = function(country) {
      return ((Christmas.countries[country] && Christmas.countries[country].width) || 40);
    }


    var mouseMove = function(event) {
      event = event || window.event;

      // only show it on first movement
      if (me.flag._new && visible && event.clientX && event.clientY) {
        document.body.appendChild(me.flag);
        document.body.style.cursor = "none";
        document.getElementById("answer").style.cursor = "none";
        me.flag._new = false;
      }

      moveFlag(me.flag,
        event.clientX + window.pageXOffset,
        event.clientY + window.pageYOffset
      );

      if (!me.readonly) {
        emit('motion', {
          x: event.clientX + window.pageXOffset,
          y: event.clientY + window.pageYOffset,
          id: me.id, // needed for quick rebroadcast
          c: me.country // needed for quick rebroadcast (possible quick registration)
        });
      }
    };

    on('motion', function(other) {
      // toss junk motion
      if (!(other.x && other.y)) return;

      if (!others[other.id] || !others[other.id].flag)
        showOther(other);

      moveFlag(others[other.id].flag, other.x, other.y);
    });

    var moveFlag = function(flag, x, y) {
      // check x and y to prevent motion on 0,0
      if (x && y) {
        flag.style.left = "" + x + "px";
        flag.style.top = "" + y + "px";
      }
    };

    var mouseClick = function(event) {
      event = event || window.event;

      // :(
      if (me.readonly || window._ie9) return;

      var x = event.clientX + window.pageXOffset;
      var y = event.clientY + window.pageYOffset;

      clickFlag(me.country, x, y);
      emit('click', {
        x: x,
        y: y,
        id: me.id // needed for quick rebroadcast
      });
    };

    on('click', function(other) {
      // :(
      if (me.readonly || window._ie9) return;

      clickFlag(others[other.id].country, other.x, other.y);
    });

    var clickFlag = function(country, x, y) {
      if (!visible) return;

      var elem = document.createElement("div");

      var width = flagWidth(country)
      var height = 20; // constant flag height
      var xOff = Math.floor(width / 2);
      var yOff = Math.floor(height / 2);

      elem.className = "click";
      elem.style.width = "" + width + "px";
      elem.style.height = "" + height + "px";
      elem.style.left = "" + (x - xOff) + "px";
      elem.style.top = "" + (y - yOff) + "px";

      document.body.appendChild(elem);
      setTimeout(function() {
        elem.style.width = "" + (width*2) + "px";
        elem.style.height = "" + (height*2) + "px";
        elem.style.borderColor = "#fff";
        elem.style.left = "" + (x - width) + "px";
        elem.style.top = "" + (y - height) + "px";
        setTimeout(function() {
          elem.parentElement.removeChild(elem);
        }, 500);
      }, 10);
    };


/**** Chat mechanics ****/

    // welcome user once, then after every 10 chat messages received.
    // turn off when the user first uses say().
    var said = false;
    var chatsSince = 0;

    var welcomeUser = function() {
      log.public("= Your name is " + me.name + ". Hello, " + me.name + ".");
      log.public("= say(\"message\") to speak, rename(\"Name\") to change names.");
    };

    var say = function(message) {
      if (!message) return;
      if (user.live.chat != "true") return;

      said = true;
      emit('chat', {
        id: me.id, // TODO: make this unnecessary
        name: me.name, // TODO: server-side
        country: me.country, // TODO: server-side post-initialization
        message: message,
        time: Date.now()
      });
    };

    // TODO: move this server-side
    var rename = function(name) {
      if (!name) return;
      me.name = name.slice(0,20);

      log.public("= Your name: " + me.name);
    };

    on('chat', function(data) {
      if (!said) {
        chatsSince += 1;
        if (chatsSince >= 10) {
          welcomeUser();
          chatsSince = 0;
        }
      }

      log.public("[" + data.country + "] " + data.name + ": " + data.message);
    });



/**** Admin powers ***/

    on('config', function(data) {
      log.info("= live config change: " + data.key + " [" + user.live[data.key] + " -> " + data.value + "]");
      user.live[data.key] = data.value;
    });

    on('command', function(data) {
      log.info("= command: " + data.command + " (" + data.arguments.join(",") + ")");
      (commands[data.command] || noop).apply(null, data.arguments);
    })

    command('blast', function(message) {
      log.public("= Server message: " + message);
    })

    command('reconnect', function() {
      log.public("= Server asked us to reconnect, closing connection");
      socket.close();
    });

    command('refresh', function() {
      log.public("= Server asked us to refresh, whooaaaaa");
      window.location = window.location;
    })


/**** rate limiting utilities **/

    // basic rate-limiter for a static value
    function ratelimit(fn, interval) {
      var last = (new Date()).getTime();
      return (function() {
        var now = (new Date()).getTime();
        if ((now - last) > interval) {
          last = now;
          return fn.apply(null, arguments);
        }
      });
    }

    // special version of ratelimit that looks to live-changeable value
    function ratelimitMouse(fn) {
      var last = (new Date()).getTime();
      return (function() {
        var now = (new Date()).getTime();
        if ((now - last) > user.live.mouse_rate) {
          last = now;
          return fn.apply(null, arguments);
        }
      });
    }


/** christmas midnight effect **/

    // live flip when it's Xmas, and when it's not again
    var flagRule = addCSSRule("img");
    var clickRule = addCSSRule("div.click");
    var legendRule = addCSSRule("div#legend");
    function flagFade(centerTime) {
      // fade out, then in
      setTimeout(function() {
        flagRule.style.opacity = 0;
        legendRule.style.display = "none";
        clickRule.style.display = "none";

        setTimeout(function() {
          flagRule.style.opacity = 1;
          legendRule.style.display = "block";
          clickRule.style.display = "block";
        }, 5000); // 2 seconds after center

      }, (centerTime - Date.now()) - 3000); // 3 seconds before center (fade is 1s)
    }


    // broken?
    function setTimers() {
      var nextXmas = Christmas.thisYear();
      // var nextXmas = new Date(Date.now() + (5 * 1000)); // 5 seconds from now
      // var nextXmas = new Date(Date.now()); // pretend we showed up a few milliseconds before

      nextXmas = nextXmas.getTime();

      var afterXmas = nextXmas + (24 * 60 * 60 * 1000); // 1 day later
      // var afterXmas = nextXmas + (10 * 1000); // 10 seconds later

      // console.log("Christmas set for: " + new Date(nextXmas));
      // console.log("Christmas ends: " + new Date(afterXmas));

      if (checkedAt < nextXmas) {

        flagFade(nextXmas);

        christmasTimer = setTimeout(function() {
          log.public("Christmas!");
          updateChristmas(true);
        }, (nextXmas - Date.now()));
      }

      if (checkedAt < afterXmas) {

        flagFade(afterXmas);

        christmasEndTimer = setTimeout(function() {
          log.public("Not Christmas.");
          updateChristmas(false);
        }, (afterXmas - Date.now()));
      }
    }


/**** minimalist logging system **/

    var log = function(message, severity) {
      if (user.log[severity]) console.log(message);
    };
    log.debug = function(message) {log(message, "debug")};
    log.info = function(message) {log(message, "info")};
    log.join = function(message) {log(message, "join")};
    log.public = function(message) {log(message, "public")};
    log.life = function(message) {log(message, "life")};


/**** misc and browser-specific fixes **/

    // IE fix: make console.log be okay
    if (!window.console) window.console = {};
    if (!window.console.log) window.console.log = function() {};

    // Firefox fix: prevent ESC from closing websockets connection
    if (window.addEventListener)
      window.addEventListener('keydown', function(e) { (e.keyCode == 27 && e.preventDefault()) })

    // IE9 fix: XDR does not allow http->https communication, fall back to http
    if (window._ie9) url = url.replace("https", "http");

    // prevent click-drags from "grabbing" image
    document.body.onmousedown = function(event) {
      event = event || window.event;
      if (event.preventDefault) event.preventDefault();
      else event.returnValue = false;
    };


/**** GO ****/

    // TODO: what happened here??
    // setTimers();
    connect(url);

  </script>
</body>
</html>